"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const Connection_1 = require("../core/Connection");
const Http_1 = require("../core/Http");
const PlayerStore_1 = require("../core/PlayerStore");
class BaseNode extends events_1.EventEmitter {
    constructor({ password, userID, shardCount, hosts }) {
        super();
        this.players = new PlayerStore_1.default(this);
        this.voiceStates = new Map();
        this.voiceServers = new Map();
        this.password = password;
        this.userID = userID;
        this.shardCount = shardCount;
        if (hosts) {
            if (hosts.rest)
                this.http = new Http_1.default(this, hosts.rest);
            if (hosts.ws)
                this.connection = typeof hosts.ws === 'string' ? new Connection_1.default(this, hosts.ws) : new Connection_1.default(this, hosts.ws.url, hosts.ws.options);
        }
    }
    load(identifier) {
        if (this.http)
            return this.http.load(identifier);
        throw new Error('no available http module');
    }
    decode(tracks) {
        if (this.http)
            return this.http.decode(tracks);
        throw new Error('no available http module');
    }
    voiceStateUpdate(packet) {
        if (packet.user_id !== this.userID)
            return Promise.resolve(false);
        this.voiceStates.set(packet.guild_id, packet.session_id);
        return this._tryConnection(packet.guild_id);
    }
    voiceServerUpdate(packet) {
        this.voiceServers.set(packet.guild_id, packet);
        return this._tryConnection(packet.guild_id);
    }
    async _tryConnection(guildID) {
        const state = this.voiceStates.get(guildID);
        const server = this.voiceServers.get(guildID);
        if (!state || !server)
            return false;
        await this.players.get(guildID).voiceUpdate(state, server);
        return true;
    }
}
exports.default = BaseNode;

//# sourceMappingURL=Node.js.map
