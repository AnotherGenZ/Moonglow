{"version":3,"sources":["base/Node.ts"],"names":[],"mappings":";;AACA,mCAAsC;AACtC,mDAA4C;AAC5C,uCAA0D;AAC1D,qDAA8C;AA8B9C,MAA8B,QAAS,SAAQ,qBAAY;IAczD,YAAY,EAAE,QAAQ,EAAE,MAAM,EAAE,UAAU,EAAE,KAAK,EAAmB;QAClE,KAAK,EAAE,CAAC;QAPH,YAAO,GAAgB,IAAI,qBAAW,CAAC,IAAI,CAAC,CAAC;QAG7C,gBAAW,GAAwB,IAAI,GAAG,EAAE,CAAC;QAC7C,iBAAY,GAAmC,IAAI,GAAG,EAAE,CAAC;QAI9D,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAE7B,IAAI,KAAK,EAAE;YACT,IAAI,KAAK,CAAC,IAAI;gBAAE,IAAI,CAAC,IAAI,GAAG,IAAI,cAAI,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;YACvD,IAAI,KAAK,CAAC,EAAE;gBAAE,IAAI,CAAC,UAAU,GAAG,OAAO,KAAK,CAAC,EAAE,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,oBAAU,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,oBAAU,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;SACtJ;IACH,CAAC;IAEM,IAAI,CAAC,UAAkB;QAC5B,IAAI,IAAI,CAAC,IAAI;YAAE,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACjD,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;IAC9C,CAAC;IAIM,MAAM,CAAC,MAAyB;QACrC,IAAI,IAAI,CAAC,IAAI;YAAE,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAC/C,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;IAC9C,CAAC;IAEM,gBAAgB,CAAC,MAAwB;QAC9C,IAAI,MAAM,CAAC,OAAO,KAAK,IAAI,CAAC,MAAM;YAAE,OAAO,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAElE,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;QACzD,OAAO,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAEM,iBAAiB,CAAC,MAAyB;QAChD,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAC/C,OAAO,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAEO,KAAK,CAAC,cAAc,CAAC,OAAe;QAC1C,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC5C,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC9C,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM;YAAE,OAAO,KAAK,CAAC;QAEpC,MAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,WAAW,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAC3D,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AA1DD,2BA0DC","file":"Node.js","sourcesContent":["import WebSocket = require('ws');\nimport { EventEmitter } from 'events';\nimport Connection from '../core/Connection';\nimport Http, { Track, TrackResponse } from '../core/Http';\nimport PlayerStore from '../core/PlayerStore';\n\nexport interface VoiceStateUpdate {\n  guild_id: string;\n  channel_id?: string;\n  user_id: string;\n  session_id: string;\n  deaf?: boolean;\n  mute?: boolean;\n  self_deaf?: boolean;\n  self_mute?: boolean;\n  suppress?: boolean;\n}\n\nexport interface VoiceServerUpdate {\n  guild_id: string;\n  token: string;\n  endpoint: string;\n}\n\nexport interface BaseNodeOptions {\n  password: string;\n  userID: string;\n  shardCount?: number;\n  hosts?: {\n    rest?: string;\n    ws?: string | { url: string, options: WebSocket.ClientOptions };\n  };\n}\n\nexport default abstract class BaseNode extends EventEmitter {\n  public abstract send(guildID: string, packet: any): Promise<any>;\n\n  public password: string;\n  public userID: string;\n  public shardCount?: number;\n\n  public connection?: Connection;\n  public players: PlayerStore = new PlayerStore(this);\n  public http?: Http;\n\n  public voiceStates: Map<string, string> = new Map();\n  public voiceServers: Map<string, VoiceServerUpdate> = new Map();\n\n  constructor({ password, userID, shardCount, hosts }: BaseNodeOptions) {\n    super();\n    this.password = password;\n    this.userID = userID;\n    this.shardCount = shardCount;\n\n    if (hosts) {\n      if (hosts.rest) this.http = new Http(this, hosts.rest);\n      if (hosts.ws) this.connection = typeof hosts.ws === 'string' ? new Connection(this, hosts.ws) : new Connection(this, hosts.ws.url, hosts.ws.options);\n    }\n  }\n\n  public load(identifier: string): Promise<TrackResponse[]> {\n    if (this.http) return this.http.load(identifier);\n    throw new Error('no available http module');\n  }\n\n  public decode(track: string): Promise<Track>;\n  public decode(tracks: string[]): Promise<Track[]>;\n  public decode(tracks: string | string[]): Promise<Track | Track[]> {\n    if (this.http) return this.http.decode(tracks);\n    throw new Error('no available http module');\n  }\n\n  public voiceStateUpdate(packet: VoiceStateUpdate) {\n    if (packet.user_id !== this.userID) return Promise.resolve(false);\n\n    this.voiceStates.set(packet.guild_id, packet.session_id);\n    return this._tryConnection(packet.guild_id);\n  }\n\n  public voiceServerUpdate(packet: VoiceServerUpdate) {\n    this.voiceServers.set(packet.guild_id, packet);\n    return this._tryConnection(packet.guild_id);\n  }\n\n  private async _tryConnection(guildID: string) {\n    const state = this.voiceStates.get(guildID);\n    const server = this.voiceServers.get(guildID);\n    if (!state || !server) return false;\n\n    await this.players.get(guildID).voiceUpdate(state, server);\n    return true;\n  }\n}\n"],"sourceRoot":"../../src"}